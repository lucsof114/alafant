"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@solana/spl-token"),t=require("@solana/web3.js"),r=require("promise-retry"),n=require("@coral-xyz/anchor"),o=require("@metaplex-foundation/mpl-token-metadata");function a(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var s=a(r);class i extends Error{constructor(e,t,r,n){super(e),this.txid=void 0,this.code=void 0,this.programIds=void 0,this.txid=t,this.code=r,this.programIds=n,Object.setPrototypeOf(this,Error.prototype)}}const c="Program failed to complete",u="Unknown error, visit the explorer",l="11111111111111111111111111111111";function d({err:t,logMessages:r}){const n=t;let o;if(n&&"string"!=typeof n){if("InsufficientFundsForRent"in n)return{message:"Insufficient funds for rent",code:1,programIds:[e.TOKEN_PROGRAM_ID.toBase58()]};{const e=n.InstructionError,[t,s]=e;var a;if("string"==typeof s){if("ProgramFailedToComplete"===s&&r){const e=function(e){let t=[];for(let r=0;r<e.length;r++){const n=e[r].match(new RegExp(/Program (\S+) failed: Program failed to complete/));n&&t.push(n[1])}return t}(r);if(e.length>0)return{message:c,programIds:e,code:o}}}else if(o=null!==(a=s.Custom)&&void 0!==a?a:e[1],r){const t=function(e,t){for(let r=0;r<e.length;r++){const n=e[r].match(new RegExp(`Program ([1-9A-HJ-NP-Za-km-z]{32,44}) failed: custom program error: 0x${t.toString(16)}`));if(n)return n[1]}}(r,o);if(t)return t===l?function(e){const t=e[1].Custom;let r="";switch(t){case 0:r="An account with the same address already exists";break;case 1:r="The account does not have enough SOL to perform the operation";break;default:r=u}return{code:t,programIds:[l],message:r}}(e):{message:u,programIds:[t],code:o}}}}return{message:"string"==typeof n?n:u,code:o}}const f={skipPreflight:!0};async function p({connection:e,serializedTransaction:r,blockhashWithExpiryBlockHeight:n}){const o=await e.sendRawTransaction(r,f);try{const t=n.lastValidBlockHeight-150;await e.confirmTransaction({...n,lastValidBlockHeight:t,signature:o},"confirmed")}catch(e){if(!(e instanceof t.TransactionExpiredBlockheightExceededError))throw e}return s.default((async t=>{const r=await e.getTransaction(o,{commitment:"confirmed",maxSupportedTransactionVersion:0});return r||t(r),r}),{retries:5,minTimeout:500})}function m(e){const t="signature"in e?e.signature:e.signatures[0];if(!t)throw new Error("Missing transaction signature, the transaction was not signed by the fee payer");return n.utils.bytes.bs58.encode(t)}const g=(e,t,r,n)=>{const{code:o,programIds:a,message:s}=d(e);if(n&&r&&null!=a&&a.includes(n.toBase58())){var c;let e=null===(c=r.errors)||void 0===c?void 0:c.find((e=>e.code===o));var u;if(e)return new i(null!==(u=e.msg)&&void 0!==u?u:e.name,t,e.code,a)}return new i(s,t,o,a)};async function h(t,r){const n=await e.Token.getAssociatedTokenAddress(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,e.NATIVE_MINT,r,!0);return{address:n,accountInfo:await t.getAccountInfo(n)}}const y=new t.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),T=new t.PublicKey("META4s4fSmpkTbZoUsgC1oBnWB31vQcmnN8giPw51Zu");function A(r,n){const o=n.equals(e.TOKEN_PROGRAM_ID)?y:T;return t.PublicKey.findProgramAddressSync([Buffer.from("metadata"),o.toBuffer(),r.toBuffer()],o)[0]}const w=e=>e.replace(/\u0000/g,"");exports.PROGRAM_FAILED_TO_COMPLETE_ERROR=c,exports.TransactionError=i,exports.UNKNOWN_ERROR=u,exports.createAndTransferWSOLTransaction=async function({connection:r,publicKey:n,blockhash:o,lastValidBlockHeight:a,amountToTransferInLamports:s}){const i=await h(r,n),c=[];i.accountInfo||c.push(e.Token.createAssociatedTokenAccountInstruction(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,e.NATIVE_MINT,i.address,n,n)),c.push(t.SystemProgram.transfer({fromPubkey:n,toPubkey:i.address,lamports:s})),c.push(e.Token.createSyncNativeInstruction(e.TOKEN_PROGRAM_ID,i.address));const u=new t.Transaction({feePayer:n,blockhash:o,lastValidBlockHeight:a});return u.add(...c),u},exports.createUnwrapSolTransaction=async function({connection:r,publicKey:n,blockhash:o,lastValidBlockHeight:a}){const s=await h(r,n),i=[];if(!s.accountInfo)return;i.push(e.Token.createCloseAccountInstruction(e.TOKEN_PROGRAM_ID,s.address,n,n,[]));const c=new t.Transaction({feePayer:n,blockhash:o,lastValidBlockHeight:a});return c.add(...i),c},exports.deserializeAccount=r=>{if(null==r||0==r.length)return;const n=e.AccountLayout.decode(r);return n.mint=new t.PublicKey(n.mint),n.owner=new t.PublicKey(n.owner),n.amount=e.u64.fromBuffer(n.amount),0===n.delegateOption?(n.delegate=null,n.delegatedAmount=new e.u64(0)):(n.delegate=new t.PublicKey(n.delegate),n.delegatedAmount=e.u64.fromBuffer(n.delegatedAmount)),n.isInitialized=0!==n.state,n.isFrozen=2===n.state,1===n.isNativeOption?(n.rentExemptReserve=e.u64.fromBuffer(n.isNative),n.isNative=!0):(n.rentExemptReserve=null,n.isNative=!1),n.closeAuthority=0===n.closeAuthorityOption?null:new t.PublicKey(n.closeAuthority),n},exports.deserializeMint=(r,n)=>{if(r.length!==e.MintLayout.span)return;const o=e.MintLayout.decode(r);return o.address=n,o.mintAuthority=0===o.mintAuthorityOption?null:new t.PublicKey(o.mintAuthority),o.supply=e.u64.fromBuffer(o.supply),o.isInitialized=0!==o.isInitialized,o.freezeAuthority=0===o.freezeAuthorityOption?null:new t.PublicKey(o.freezeAuthority),o},exports.fetchMintInfos=async function(t,r){return(await n.utils.rpc.getMultipleAccounts(t,r)).reduce(((t,n,o)=>(n&&t.push([r[o].toString(),{...e.MintLayout.decode(n.account.data),programId:n.account.owner}]),t)),new Array)},exports.fetchTokenMetadatas=async function(e,t){const r=t.map((e=>A(e.mint,e.programId)));return(await n.utils.rpc.getMultipleAccounts(e,r)).reduce(((e,t)=>{if(t){const r=o.Metadata.deserialize(t.account.data)[0];r.data.name=w(r.data.name),r.data.symbol=w(r.data.symbol),r.data.uri=w(r.data.uri),e.push({publicKey:t.publicKey,account:r})}return e}),new Array)},exports.findMetadataAddress=A,exports.getSignature=m,exports.handleSendTransaction=async({connection:e,signedTransaction:r,blockhash:n,lastValidBlockHeight:o,idl:a,skipPreflight:s,idlProgramId:c})=>{var u;let l=Buffer.from(r.serialize()),d=m(r);if(!s){const{value:n}=await e.simulateTransaction("message"in r?r:new t.VersionedTransaction(r.compileMessage()),{replaceRecentBlockhash:!0,commitment:"processed"}),{err:o,logs:s}=n;if(o)return{error:g({err:o,logMessages:s},d,a,c),txid:void 0}}let f=await p({connection:e,serializedTransaction:l,blockhashWithExpiryBlockHeight:{blockhash:n,lastValidBlockHeight:o}});return f?null!==(u=f.meta)&&void 0!==u&&u.err?{error:g(f.meta,d,a,c),transactionResponse:f,txid:d}:{transactionResponse:f,txid:d}:{error:new i("Transaction is expired and was not confirmed. Please try again."),txid:void 0}},exports.parseErrorForTransaction=d,exports.parseErrorWithIdl=g,exports.removeEmptyChars=w,exports.transactionSenderAndConfirmationWaiter=p;
//# sourceMappingURL=optimist.cjs.production.min.js.map
