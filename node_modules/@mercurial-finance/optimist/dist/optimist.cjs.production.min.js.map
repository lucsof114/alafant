{"version":3,"file":"optimist.cjs.production.min.js","sources":["../src/tx/errors.ts","../src/tx/poll.ts","../src/tx/tx.ts","../src/utils/wrapSOL.ts","../src/metadata/index.ts","../src/utils/deserializeAccount.ts","../src/utils/deserializeMint.ts"],"sourcesContent":["import { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { TransactionResponse, VersionedTransactionResponse } from '@solana/web3.js';\n\ntype IntrusctionError = [index: number, errorMsg: string];\ntype CustomInstructionError = [index: number, code: { Custom: number }];\ninterface ITransactionError {\n  InstructionError: CustomInstructionError | IntrusctionError;\n}\n\ninterface IInsufficientFundsForRent {\n  InsufficientFundsForRent: {\n    account_index: number;\n  };\n}\n\nexport class TransactionError extends Error {\n  constructor(m: string, public txid?: string, public code?: number, public programIds?: string[]) {\n    super(m);\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, Error.prototype);\n  }\n}\nexport const PROGRAM_FAILED_TO_COMPLETE_ERROR = 'Program failed to complete';\nexport const UNKNOWN_ERROR = 'Unknown error, visit the explorer';\nconst SYSTEM_PROGRAM_ID = '11111111111111111111111111111111';\n\nexport type ParseErrorParam = Pick<\n  NonNullable<Pick<VersionedTransactionResponse | TransactionResponse, 'meta'>['meta']>,\n  'err' | 'logMessages'\n>;\nexport function parseErrorForTransaction({ err, logMessages }: ParseErrorParam): {\n  message: string;\n  programIds?: string[];\n  code?: number;\n} {\n  const transactionError = err;\n  let errorCode;\n\n  if (transactionError && typeof transactionError !== 'string') {\n    let error = transactionError as ITransactionError | IInsufficientFundsForRent;\n\n    if ('InsufficientFundsForRent' in error) {\n      return {\n        message: 'Insufficient funds for rent',\n        code: 1,\n        programIds: [TOKEN_PROGRAM_ID.toBase58()],\n      };\n    } else {\n      const instructionError = (transactionError as ITransactionError).InstructionError;\n\n      const [index, errorMsg] = instructionError;\n\n      if (typeof errorMsg === 'string') {\n        if (errorMsg === 'ProgramFailedToComplete') {\n          if (logMessages) {\n            const failedProgramIds = getFailedExceededInstructionsPrograms(logMessages);\n            if (failedProgramIds.length > 0) {\n              return {\n                message: PROGRAM_FAILED_TO_COMPLETE_ERROR,\n                programIds: failedProgramIds,\n                code: errorCode,\n              };\n            }\n          }\n        }\n      } else {\n        errorCode = errorMsg.Custom ?? (instructionError[1] as any as number);\n        if (logMessages) {\n          const failedProgramId = getFailedProgram(logMessages, errorCode);\n          if (failedProgramId) {\n            if (failedProgramId === SYSTEM_PROGRAM_ID) {\n              return getSystemProgramError(instructionError as CustomInstructionError);\n            }\n\n            return {\n              message: UNKNOWN_ERROR,\n              programIds: [failedProgramId],\n              code: errorCode,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  return { message: typeof transactionError === 'string' ? transactionError : UNKNOWN_ERROR, code: errorCode };\n}\n\nfunction getFailedExceededInstructionsPrograms(logMessages: String[]) {\n  let founds = [];\n  for (let i = 0; i < logMessages.length; i++) {\n    const log = logMessages[i];\n\n    const found = log.match(new RegExp(/Program (\\S+) failed: Program failed to complete/));\n\n    if (found) {\n      founds.push(found[1]);\n    }\n  }\n\n  return founds;\n}\n\nfunction getFailedProgram(logMessages: String[], errorCode: number | string) {\n  for (let i = 0; i < logMessages.length; i++) {\n    const log = logMessages[i];\n\n    const found = log.match(\n      new RegExp(`Program ([1-9A-HJ-NP-Za-km-z]{32,44}) failed: custom program error: 0x${errorCode.toString(16)}`),\n    );\n\n    if (found) {\n      return found[1];\n    }\n  }\n\n  return;\n}\n\nfunction getSystemProgramError(instructionError: CustomInstructionError) {\n  const code = instructionError[1].Custom;\n\n  let message = '';\n  switch (code) {\n    // https://github.com/solana-labs/solana/blob/22a18a68e3ee68ae013d647e62e12128433d7230/sdk/program/src/system_instruction.rs#L12-L26\n    // TODO: Do we need to translate all error codes.\n    case 0: {\n      message = 'An account with the same address already exists';\n      break;\n    }\n    case 1: {\n      message = 'The account does not have enough SOL to perform the operation';\n      break;\n    }\n    default: {\n      message = UNKNOWN_ERROR;\n    }\n  }\n\n  return {\n    code,\n    programIds: [SYSTEM_PROGRAM_ID],\n    message,\n  };\n}\n","import {\n  BlockhashWithExpiryBlockHeight,\n  Connection,\n  TransactionExpiredBlockheightExceededError,\n  VersionedTransactionResponse,\n} from '@solana/web3.js';\nimport promiseRetry from 'promise-retry';\n\ntype TransactionSenderAndConfirmationWaiterArgs = {\n  connection: Connection;\n  serializedTransaction: Buffer;\n  blockhashWithExpiryBlockHeight: BlockhashWithExpiryBlockHeight;\n};\n\nconst SEND_OPTIONS = {\n  skipPreflight: true,\n};\n\nexport async function transactionSenderAndConfirmationWaiter({\n  connection,\n  serializedTransaction,\n  blockhashWithExpiryBlockHeight,\n}: TransactionSenderAndConfirmationWaiterArgs): Promise<VersionedTransactionResponse | null> {\n  const txid = await connection.sendRawTransaction(serializedTransaction, SEND_OPTIONS);\n\n  try {\n    const lastValidBlockHeight = blockhashWithExpiryBlockHeight.lastValidBlockHeight - 150;\n    // this would throw TransactionExpiredBlockheightExceededError\n    await connection.confirmTransaction(\n      {\n        ...blockhashWithExpiryBlockHeight,\n        lastValidBlockHeight,\n        signature: txid,\n      },\n      'confirmed',\n    );\n  } catch (e) {\n    if (e instanceof TransactionExpiredBlockheightExceededError) {\n      // we consume this error and getTransaciton would return null\n    } else {\n      // invalid state from web3.js\n      throw e;\n    }\n  }\n\n  // in case rpc is not synced yet, we add some retries\n  const response = promiseRetry(\n    async (retry) => {\n      const response = await connection.getTransaction(txid, {\n        commitment: 'confirmed',\n        maxSupportedTransactionVersion: 0,\n      });\n      if (!response) {\n        retry(response);\n      }\n      return response;\n    },\n    {\n      retries: 5,\n      minTimeout: 500,\n    },\n  );\n\n  return response;\n}\n","import { type Idl, utils } from '@coral-xyz/anchor';\nimport {\n  Connection,\n  Blockhash,\n  Transaction,\n  VersionedTransaction,\n  PublicKey,\n  VersionedTransactionResponse,\n} from '@solana/web3.js';\nimport { transactionSenderAndConfirmationWaiter } from './poll';\nimport { ParseErrorParam, TransactionError, parseErrorForTransaction } from './errors';\n\ninterface IHandleSendTransactionOptions {\n  connection: Connection;\n  signedTransaction: VersionedTransaction | Transaction;\n  blockhash: Blockhash;\n  lastValidBlockHeight: number;\n  skipPreflight?: boolean;\n  idl?: Idl;\n  idlProgramId?: PublicKey;\n}\n\nexport function getSignature(transaction: Transaction | VersionedTransaction): string {\n  const signature = 'signature' in transaction ? transaction.signature : transaction.signatures[0];\n  if (!signature) {\n    throw new Error('Missing transaction signature, the transaction was not signed by the fee payer');\n  }\n  return utils.bytes.bs58.encode(signature);\n}\n\ninterface IHandleSendTransactionError {\n  error: TransactionError;\n  transactionResponse?: VersionedTransactionResponse;\n  txid?: string;\n}\n\ninterface IHandleSendTransactionResponse {\n  transactionResponse: VersionedTransactionResponse;\n  txid: string;\n}\n\nexport const handleSendTransaction = async ({\n  connection,\n  signedTransaction,\n  blockhash,\n  lastValidBlockHeight,\n  idl,\n  skipPreflight,\n  idlProgramId,\n}: IHandleSendTransactionOptions): Promise<IHandleSendTransactionError | IHandleSendTransactionResponse> => {\n  let serializedTransaction: Buffer = Buffer.from(signedTransaction.serialize());\n\n  let signature = getSignature(signedTransaction);\n  if (!skipPreflight) {\n    const { value: transactionResponse } = await connection.simulateTransaction(\n      'message' in signedTransaction ? signedTransaction : new VersionedTransaction(signedTransaction.compileMessage()),\n      {\n        replaceRecentBlockhash: true,\n        commitment: 'processed',\n      },\n    );\n\n    const { err, logs } = transactionResponse;\n\n    if (err) {\n      const error = parseErrorWithIdl({ err, logMessages: logs }, signature, idl, idlProgramId);\n      return {\n        error,\n        txid: undefined,\n      };\n    }\n  }\n\n  let transactionResponse = await transactionSenderAndConfirmationWaiter({\n    connection,\n    serializedTransaction,\n    blockhashWithExpiryBlockHeight: {\n      blockhash,\n      lastValidBlockHeight,\n    },\n  });\n\n  if (!transactionResponse) {\n    const error = new TransactionError('Transaction is expired and was not confirmed. Please try again.');\n\n    return {\n      error,\n      txid: undefined,\n    };\n  }\n\n  if (transactionResponse.meta?.err) {\n    const error = parseErrorWithIdl(transactionResponse.meta, signature, idl, idlProgramId);\n\n    return {\n      error,\n      transactionResponse,\n      txid: signature,\n    };\n  }\n\n  return { transactionResponse, txid: signature };\n};\n\nexport const parseErrorWithIdl = (errorParams: ParseErrorParam, txid: string, idl?: Idl, idlProgramId?: PublicKey) => {\n  const { code, programIds, message } = parseErrorForTransaction(errorParams);\n\n  if (idlProgramId && idl) {\n    if (programIds?.includes(idlProgramId.toBase58())) {\n      let error = idl.errors?.find((error) => {\n        return error.code === code;\n      });\n\n      if (error) {\n        // msg might not be exposed by IDL, so we fallback to name\n        return new TransactionError(error.msg ?? error.name, txid, error.code, programIds);\n      }\n    }\n  }\n\n  return new TransactionError(message, txid, code, programIds);\n};\n","import { ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\nimport { Blockhash, Connection, PublicKey, SystemProgram, Transaction } from '@solana/web3.js';\n\nasync function getWSolATA(connection: Connection, publicKey: PublicKey) {\n  const wSolAddress = await Token.getAssociatedTokenAddress(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    NATIVE_MINT,\n    publicKey,\n    true,\n  );\n  const accountInfo = await connection.getAccountInfo(wSolAddress);\n  return { address: wSolAddress, accountInfo };\n}\n\ninterface CreateTxParams {\n  connection: Connection;\n  publicKey: PublicKey;\n  blockhash: Blockhash;\n  lastValidBlockHeight: number;\n}\n\nasync function createAndTransferWSOLTransaction({\n  connection,\n  publicKey,\n  blockhash,\n  lastValidBlockHeight,\n  amountToTransferInLamports,\n}: CreateTxParams & { amountToTransferInLamports: number }) {\n  const wSolAccount = await getWSolATA(connection, publicKey);\n  const instructions = [];\n\n  // If no accountInfo, create one\n  if (!wSolAccount.accountInfo) {\n    // Create ATA account\n    instructions.push(\n      Token.createAssociatedTokenAccountInstruction(\n        ASSOCIATED_TOKEN_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        NATIVE_MINT,\n        wSolAccount.address,\n        publicKey,\n        publicKey,\n      ),\n    );\n  }\n\n  // Fund account and sync\n  instructions.push(\n    SystemProgram.transfer({\n      fromPubkey: publicKey,\n      toPubkey: wSolAccount.address,\n      lamports: amountToTransferInLamports,\n    }),\n  );\n  instructions.push(\n    // This is not exposed by the types, but indeed it exists\n    (Token as any).createSyncNativeInstruction(TOKEN_PROGRAM_ID, wSolAccount.address),\n  );\n\n  const transaction = new Transaction({ feePayer: publicKey, blockhash, lastValidBlockHeight });\n  transaction.add(...instructions);\n  return transaction;\n}\n\nasync function createUnwrapSolTransaction({ connection, publicKey, blockhash, lastValidBlockHeight }: CreateTxParams) {\n  const wSolAccount = await getWSolATA(connection, publicKey);\n  const instructions = [];\n\n  if (!wSolAccount.accountInfo) {\n    return;\n  }\n  // Close account\n  instructions.push(\n    Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, wSolAccount.address, publicKey, publicKey, []),\n  );\n\n  const transaction = new Transaction({ feePayer: publicKey, blockhash, lastValidBlockHeight });\n  transaction.add(...instructions);\n  return transaction;\n}\n\nexport { createAndTransferWSOLTransaction, createUnwrapSolTransaction };\n","import { Metadata } from '@metaplex-foundation/mpl-token-metadata';\nimport { utils } from '@coral-xyz/anchor';\nimport { MintLayout, MintInfo, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { Connection, PublicKey } from '@solana/web3.js';\n\nconst TOKEN_METADATA_PROGRAM_ID = new PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');\n\n// This is not an official program but a community deployement\nconst TOKEN_2022_METADATA_PROGRAM_ID = new PublicKey('META4s4fSmpkTbZoUsgC1oBnWB31vQcmnN8giPw51Zu');\n\nexport function findMetadataAddress(mint: PublicKey, tokenProgramId: PublicKey): PublicKey {\n  const metadataProgramId = tokenProgramId.equals(TOKEN_PROGRAM_ID)\n    ? TOKEN_METADATA_PROGRAM_ID\n    : TOKEN_2022_METADATA_PROGRAM_ID;\n\n  return PublicKey.findProgramAddressSync(\n    [Buffer.from('metadata'), metadataProgramId.toBuffer(), mint.toBuffer()],\n    metadataProgramId,\n  )[0];\n}\n\ntype TokenMetadata = {\n  publicKey: PublicKey;\n  account: Metadata;\n};\n\ntype TokenMintWithProgramId = {\n  mint: PublicKey;\n  programId: PublicKey;\n};\n\ninterface RawMintWithProgramId extends MintInfo {\n  programId: PublicKey;\n}\n\nexport async function fetchMintInfos(\n  connection: Connection,\n  mints: PublicKey[],\n): Promise<Array<[string, RawMintWithProgramId]>> {\n  const results = (await utils.rpc.getMultipleAccounts(connection, mints)).reduce((acc, m, idx) => {\n    if (m) {\n      acc.push([\n        mints[idx].toString(),\n        {\n          ...MintLayout.decode(m.account.data),\n          programId: m.account.owner,\n        },\n      ]);\n    }\n    return acc;\n  }, new Array<[string, RawMintWithProgramId]>());\n\n  return results;\n}\n\nexport const removeEmptyChars = (value: string) => value.replace(/\\u0000/g, '');\n\nexport async function fetchTokenMetadatas(\n  connection: Connection,\n  tokens: TokenMintWithProgramId[],\n): Promise<TokenMetadata[]> {\n  const metadataAddresses = tokens.map((t) => findMetadataAddress(t.mint, t.programId));\n\n  const tokenMetaAccounts = (await utils.rpc.getMultipleAccounts(connection, metadataAddresses)).reduce(\n    (acc, keyedAccount) => {\n      if (keyedAccount) {\n        const metadata = Metadata.deserialize(keyedAccount.account.data)[0];\n        metadata.data.name = removeEmptyChars(metadata.data.name);\n        metadata.data.symbol = removeEmptyChars(metadata.data.symbol);\n        metadata.data.uri = removeEmptyChars(metadata.data.uri);\n\n        acc.push({\n          publicKey: keyedAccount.publicKey,\n          account: metadata,\n        });\n      }\n      return acc;\n    },\n    new Array<TokenMetadata>(),\n  );\n\n  return tokenMetaAccounts;\n}\n","import { AccountInfo, AccountLayout, u64 } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\n\nexport const deserializeAccount = (data: Buffer | undefined): AccountInfo | undefined => {\n  if (data == undefined || data.length == 0) {\n    return undefined;\n  }\n\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { u64, MintInfo, MintLayout } from '@solana/spl-token';\n\n// Backward compatibility for new Mint.\nexport type Mint = MintInfo & {\n  address?: PublicKey;\n};\n\nexport const deserializeMint = (data: Buffer, address?: PublicKey) => {\n  if (data.length !== MintLayout.span) {\n    // This is causing problem with mainnet token\n    // throw new Error('Not a valid Mint')\n    return;\n  }\n\n  const mintInfo = MintLayout.decode(data);\n  mintInfo.address = address;\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as Mint;\n};\n"],"names":["TransactionError","Error","constructor","m","txid","code","programIds","super","this","Object","setPrototypeOf","prototype","PROGRAM_FAILED_TO_COMPLETE_ERROR","UNKNOWN_ERROR","SYSTEM_PROGRAM_ID","parseErrorForTransaction","err","logMessages","transactionError","errorCode","message","TOKEN_PROGRAM_ID","toBase58","instructionError","InstructionError","index","errorMsg","_errorMsg$Custom","failedProgramIds","founds","i","length","found","match","RegExp","push","getFailedExceededInstructionsPrograms","Custom","failedProgramId","toString","getFailedProgram","getSystemProgramError","SEND_OPTIONS","skipPreflight","async","transactionSenderAndConfirmationWaiter","connection","serializedTransaction","blockhashWithExpiryBlockHeight","sendRawTransaction","lastValidBlockHeight","confirmTransaction","signature","e","TransactionExpiredBlockheightExceededError","promiseRetry","response","getTransaction","commitment","maxSupportedTransactionVersion","retry","retries","minTimeout","getSignature","transaction","signatures","utils","bytes","bs58","encode","handleSendTransaction","parseErrorWithIdl","errorParams","idl","idlProgramId","includes","_idl$errors","error","errors","find","_error$msg","msg","name","getWSolATA","publicKey","wSolAddress","Token","getAssociatedTokenAddress","ASSOCIATED_TOKEN_PROGRAM_ID","NATIVE_MINT","address","accountInfo","getAccountInfo","TOKEN_METADATA_PROGRAM_ID","PublicKey","TOKEN_2022_METADATA_PROGRAM_ID","findMetadataAddress","mint","tokenProgramId","metadataProgramId","equals","findProgramAddressSync","Buffer","from","toBuffer","removeEmptyChars","value","replace","blockhash","amountToTransferInLamports","wSolAccount","instructions","createAssociatedTokenAccountInstruction","SystemProgram","transfer","fromPubkey","toPubkey","lamports","createSyncNativeInstruction","Transaction","feePayer","add","createCloseAccountInstruction","data","undefined","AccountLayout","decode","owner","amount","u64","fromBuffer","delegateOption","delegate","delegatedAmount","isInitialized","state","isFrozen","isNativeOption","rentExemptReserve","isNative","closeAuthority","closeAuthorityOption","deserializeMint","MintLayout","span","mintInfo","mintAuthority","mintAuthorityOption","supply","freezeAuthority","freezeAuthorityOption","mints","rpc","getMultipleAccounts","reduce","acc","idx","account","programId","Array","tokens","metadataAddresses","map","t","keyedAccount","metadata","Metadata","deserialize","symbol","uri","signedTransaction","_transactionResponse$","serialize","transactionResponse","simulateTransaction","VersionedTransaction","compileMessage","replaceRecentBlockhash","logs","meta"],"mappings":"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"}