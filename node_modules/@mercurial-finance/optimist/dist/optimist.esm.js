import { TOKEN_PROGRAM_ID, AccountLayout, u64, MintLayout, Token, ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT } from '@solana/spl-token';
import { TransactionExpiredBlockheightExceededError, VersionedTransaction, PublicKey, SystemProgram, Transaction } from '@solana/web3.js';
import promiseRetry from 'promise-retry';
import { utils } from '@coral-xyz/anchor';
import { Metadata } from '@metaplex-foundation/mpl-token-metadata';

class TransactionError extends Error {
  constructor(m, txid, code, programIds) {
    super(m);
    this.txid = void 0;
    this.code = void 0;
    this.programIds = void 0;
    this.txid = txid;
    this.code = code;
    this.programIds = programIds;
    // Set the prototype explicitly.
    Object.setPrototypeOf(this, Error.prototype);
  }
}
const PROGRAM_FAILED_TO_COMPLETE_ERROR = 'Program failed to complete';
const UNKNOWN_ERROR = 'Unknown error, visit the explorer';
const SYSTEM_PROGRAM_ID = '11111111111111111111111111111111';
function parseErrorForTransaction({
  err,
  logMessages
}) {
  const transactionError = err;
  let errorCode;
  if (transactionError && typeof transactionError !== 'string') {
    let error = transactionError;
    if ('InsufficientFundsForRent' in error) {
      return {
        message: 'Insufficient funds for rent',
        code: 1,
        programIds: [TOKEN_PROGRAM_ID.toBase58()]
      };
    } else {
      const instructionError = transactionError.InstructionError;
      const [index, errorMsg] = instructionError;
      if (typeof errorMsg === 'string') {
        if (errorMsg === 'ProgramFailedToComplete') {
          if (logMessages) {
            const failedProgramIds = getFailedExceededInstructionsPrograms(logMessages);
            if (failedProgramIds.length > 0) {
              return {
                message: PROGRAM_FAILED_TO_COMPLETE_ERROR,
                programIds: failedProgramIds,
                code: errorCode
              };
            }
          }
        }
      } else {
        var _errorMsg$Custom;
        errorCode = (_errorMsg$Custom = errorMsg.Custom) !== null && _errorMsg$Custom !== void 0 ? _errorMsg$Custom : instructionError[1];
        if (logMessages) {
          const failedProgramId = getFailedProgram(logMessages, errorCode);
          if (failedProgramId) {
            if (failedProgramId === SYSTEM_PROGRAM_ID) {
              return getSystemProgramError(instructionError);
            }
            return {
              message: UNKNOWN_ERROR,
              programIds: [failedProgramId],
              code: errorCode
            };
          }
        }
      }
    }
  }
  return {
    message: typeof transactionError === 'string' ? transactionError : UNKNOWN_ERROR,
    code: errorCode
  };
}
function getFailedExceededInstructionsPrograms(logMessages) {
  let founds = [];
  for (let i = 0; i < logMessages.length; i++) {
    const log = logMessages[i];
    const found = log.match(new RegExp(/Program (\S+) failed: Program failed to complete/));
    if (found) {
      founds.push(found[1]);
    }
  }
  return founds;
}
function getFailedProgram(logMessages, errorCode) {
  for (let i = 0; i < logMessages.length; i++) {
    const log = logMessages[i];
    const found = log.match(new RegExp(`Program ([1-9A-HJ-NP-Za-km-z]{32,44}) failed: custom program error: 0x${errorCode.toString(16)}`));
    if (found) {
      return found[1];
    }
  }
  return;
}
function getSystemProgramError(instructionError) {
  const code = instructionError[1].Custom;
  let message = '';
  switch (code) {
    // https://github.com/solana-labs/solana/blob/22a18a68e3ee68ae013d647e62e12128433d7230/sdk/program/src/system_instruction.rs#L12-L26
    // TODO: Do we need to translate all error codes.
    case 0:
      {
        message = 'An account with the same address already exists';
        break;
      }
    case 1:
      {
        message = 'The account does not have enough SOL to perform the operation';
        break;
      }
    default:
      {
        message = UNKNOWN_ERROR;
      }
  }
  return {
    code,
    programIds: [SYSTEM_PROGRAM_ID],
    message
  };
}

const SEND_OPTIONS = {
  skipPreflight: true
};
async function transactionSenderAndConfirmationWaiter({
  connection,
  serializedTransaction,
  blockhashWithExpiryBlockHeight
}) {
  const txid = await connection.sendRawTransaction(serializedTransaction, SEND_OPTIONS);
  try {
    const lastValidBlockHeight = blockhashWithExpiryBlockHeight.lastValidBlockHeight - 150;
    // this would throw TransactionExpiredBlockheightExceededError
    await connection.confirmTransaction({
      ...blockhashWithExpiryBlockHeight,
      lastValidBlockHeight,
      signature: txid
    }, 'confirmed');
  } catch (e) {
    if (e instanceof TransactionExpiredBlockheightExceededError) ; else {
      // invalid state from web3.js
      throw e;
    }
  }
  // in case rpc is not synced yet, we add some retries
  const response = promiseRetry(async retry => {
    const response = await connection.getTransaction(txid, {
      commitment: 'confirmed',
      maxSupportedTransactionVersion: 0
    });
    if (!response) {
      retry(response);
    }
    return response;
  }, {
    retries: 5,
    minTimeout: 500
  });
  return response;
}

function getSignature(transaction) {
  const signature = 'signature' in transaction ? transaction.signature : transaction.signatures[0];
  if (!signature) {
    throw new Error('Missing transaction signature, the transaction was not signed by the fee payer');
  }
  return utils.bytes.bs58.encode(signature);
}
const handleSendTransaction = async ({
  connection,
  signedTransaction,
  blockhash,
  lastValidBlockHeight,
  idl,
  skipPreflight,
  idlProgramId
}) => {
  var _transactionResponse$;
  let serializedTransaction = Buffer.from(signedTransaction.serialize());
  let signature = getSignature(signedTransaction);
  if (!skipPreflight) {
    const {
      value: transactionResponse
    } = await connection.simulateTransaction('message' in signedTransaction ? signedTransaction : new VersionedTransaction(signedTransaction.compileMessage()), {
      replaceRecentBlockhash: true,
      commitment: 'processed'
    });
    const {
      err,
      logs
    } = transactionResponse;
    if (err) {
      const error = parseErrorWithIdl({
        err,
        logMessages: logs
      }, signature, idl, idlProgramId);
      return {
        error,
        txid: undefined
      };
    }
  }
  let transactionResponse = await transactionSenderAndConfirmationWaiter({
    connection,
    serializedTransaction,
    blockhashWithExpiryBlockHeight: {
      blockhash,
      lastValidBlockHeight
    }
  });
  if (!transactionResponse) {
    const error = new TransactionError('Transaction is expired and was not confirmed. Please try again.');
    return {
      error,
      txid: undefined
    };
  }
  if ((_transactionResponse$ = transactionResponse.meta) !== null && _transactionResponse$ !== void 0 && _transactionResponse$.err) {
    const error = parseErrorWithIdl(transactionResponse.meta, signature, idl, idlProgramId);
    return {
      error,
      transactionResponse,
      txid: signature
    };
  }
  return {
    transactionResponse,
    txid: signature
  };
};
const parseErrorWithIdl = (errorParams, txid, idl, idlProgramId) => {
  const {
    code,
    programIds,
    message
  } = parseErrorForTransaction(errorParams);
  if (idlProgramId && idl) {
    if (programIds !== null && programIds !== void 0 && programIds.includes(idlProgramId.toBase58())) {
      var _idl$errors;
      let error = (_idl$errors = idl.errors) === null || _idl$errors === void 0 ? void 0 : _idl$errors.find(error => {
        return error.code === code;
      });
      if (error) {
        var _error$msg;
        // msg might not be exposed by IDL, so we fallback to name
        return new TransactionError((_error$msg = error.msg) !== null && _error$msg !== void 0 ? _error$msg : error.name, txid, error.code, programIds);
      }
    }
  }
  return new TransactionError(message, txid, code, programIds);
};

const deserializeAccount = data => {
  if (data == undefined || data.length == 0) {
    return undefined;
  }
  const accountInfo = AccountLayout.decode(data);
  accountInfo.mint = new PublicKey(accountInfo.mint);
  accountInfo.owner = new PublicKey(accountInfo.owner);
  accountInfo.amount = u64.fromBuffer(accountInfo.amount);
  if (accountInfo.delegateOption === 0) {
    accountInfo.delegate = null;
    accountInfo.delegatedAmount = new u64(0);
  } else {
    accountInfo.delegate = new PublicKey(accountInfo.delegate);
    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);
  }
  accountInfo.isInitialized = accountInfo.state !== 0;
  accountInfo.isFrozen = accountInfo.state === 2;
  if (accountInfo.isNativeOption === 1) {
    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);
    accountInfo.isNative = true;
  } else {
    accountInfo.rentExemptReserve = null;
    accountInfo.isNative = false;
  }
  if (accountInfo.closeAuthorityOption === 0) {
    accountInfo.closeAuthority = null;
  } else {
    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);
  }
  return accountInfo;
};

const deserializeMint = (data, address) => {
  if (data.length !== MintLayout.span) {
    // This is causing problem with mainnet token
    // throw new Error('Not a valid Mint')
    return;
  }
  const mintInfo = MintLayout.decode(data);
  mintInfo.address = address;
  if (mintInfo.mintAuthorityOption === 0) {
    mintInfo.mintAuthority = null;
  } else {
    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);
  }
  mintInfo.supply = u64.fromBuffer(mintInfo.supply);
  mintInfo.isInitialized = mintInfo.isInitialized !== 0;
  if (mintInfo.freezeAuthorityOption === 0) {
    mintInfo.freezeAuthority = null;
  } else {
    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);
  }
  return mintInfo;
};

async function getWSolATA(connection, publicKey) {
  const wSolAddress = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, NATIVE_MINT, publicKey, true);
  const accountInfo = await connection.getAccountInfo(wSolAddress);
  return {
    address: wSolAddress,
    accountInfo
  };
}
async function createAndTransferWSOLTransaction({
  connection,
  publicKey,
  blockhash,
  lastValidBlockHeight,
  amountToTransferInLamports
}) {
  const wSolAccount = await getWSolATA(connection, publicKey);
  const instructions = [];
  // If no accountInfo, create one
  if (!wSolAccount.accountInfo) {
    // Create ATA account
    instructions.push(Token.createAssociatedTokenAccountInstruction(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, NATIVE_MINT, wSolAccount.address, publicKey, publicKey));
  }
  // Fund account and sync
  instructions.push(SystemProgram.transfer({
    fromPubkey: publicKey,
    toPubkey: wSolAccount.address,
    lamports: amountToTransferInLamports
  }));
  instructions.push(
  // This is not exposed by the types, but indeed it exists
  Token.createSyncNativeInstruction(TOKEN_PROGRAM_ID, wSolAccount.address));
  const transaction = new Transaction({
    feePayer: publicKey,
    blockhash,
    lastValidBlockHeight
  });
  transaction.add(...instructions);
  return transaction;
}
async function createUnwrapSolTransaction({
  connection,
  publicKey,
  blockhash,
  lastValidBlockHeight
}) {
  const wSolAccount = await getWSolATA(connection, publicKey);
  const instructions = [];
  if (!wSolAccount.accountInfo) {
    return;
  }
  // Close account
  instructions.push(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, wSolAccount.address, publicKey, publicKey, []));
  const transaction = new Transaction({
    feePayer: publicKey,
    blockhash,
    lastValidBlockHeight
  });
  transaction.add(...instructions);
  return transaction;
}

const TOKEN_METADATA_PROGRAM_ID = /*#__PURE__*/new PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');
// This is not an official program but a community deployement
const TOKEN_2022_METADATA_PROGRAM_ID = /*#__PURE__*/new PublicKey('META4s4fSmpkTbZoUsgC1oBnWB31vQcmnN8giPw51Zu');
function findMetadataAddress(mint, tokenProgramId) {
  const metadataProgramId = tokenProgramId.equals(TOKEN_PROGRAM_ID) ? TOKEN_METADATA_PROGRAM_ID : TOKEN_2022_METADATA_PROGRAM_ID;
  return PublicKey.findProgramAddressSync([Buffer.from('metadata'), metadataProgramId.toBuffer(), mint.toBuffer()], metadataProgramId)[0];
}
async function fetchMintInfos(connection, mints) {
  const results = (await utils.rpc.getMultipleAccounts(connection, mints)).reduce((acc, m, idx) => {
    if (m) {
      acc.push([mints[idx].toString(), {
        ...MintLayout.decode(m.account.data),
        programId: m.account.owner
      }]);
    }
    return acc;
  }, new Array());
  return results;
}
const removeEmptyChars = value => value.replace(/\u0000/g, '');
async function fetchTokenMetadatas(connection, tokens) {
  const metadataAddresses = tokens.map(t => findMetadataAddress(t.mint, t.programId));
  const tokenMetaAccounts = (await utils.rpc.getMultipleAccounts(connection, metadataAddresses)).reduce((acc, keyedAccount) => {
    if (keyedAccount) {
      const metadata = Metadata.deserialize(keyedAccount.account.data)[0];
      metadata.data.name = removeEmptyChars(metadata.data.name);
      metadata.data.symbol = removeEmptyChars(metadata.data.symbol);
      metadata.data.uri = removeEmptyChars(metadata.data.uri);
      acc.push({
        publicKey: keyedAccount.publicKey,
        account: metadata
      });
    }
    return acc;
  }, new Array());
  return tokenMetaAccounts;
}

export { PROGRAM_FAILED_TO_COMPLETE_ERROR, TransactionError, UNKNOWN_ERROR, createAndTransferWSOLTransaction, createUnwrapSolTransaction, deserializeAccount, deserializeMint, fetchMintInfos, fetchTokenMetadatas, findMetadataAddress, getSignature, handleSendTransaction, parseErrorForTransaction, parseErrorWithIdl, removeEmptyChars, transactionSenderAndConfirmationWaiter };
//# sourceMappingURL=optimist.esm.js.map
